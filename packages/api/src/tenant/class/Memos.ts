import { Attachment, MemoStatus, MemosValidationUtils, MemoType } from '@toke/shared';

import MemosModel from '../model/MemosModel.js';
import W from '../../tools/watcher.js';
import G from '../../tools/glossary.js';
import {
  responseStructure as RS,
  responseValue,
  tableName,
  ViewMode,
} from '../../utils/response.model.js';
import { TenantRevision } from '../../tools/revision.js';

import User from './User.js';
import WorkSessions from './WorkSessions.js';
import TimeEntries from './TimeEntries.js';

export default class Memos extends MemosModel {
  private authorObj?: User;
  private targetObj?: User;
  private validatorObj?: User;
  private sessionObj?: WorkSessions;

  constructor() {
    super();
  }

  // === MÉTHODES STATIQUES DE CHARGEMENT ===

  static _load(identifier: any, byGuid: boolean = false): Promise<Memos | null> {
    return new Memos().load(identifier, byGuid);
  }

  static _list(
    conditions: Record<string, any> = {},
    paginationOptions: { offset?: number; limit?: number } = {},
  ): Promise<Memos[] | null> {
    return new Memos().list(conditions, paginationOptions);
  }

  static _listByAuthor(author_id: number): Promise<Memos[] | null> {
    return new Memos().listByAuthor(author_id);
  }

  static _listByTarget(target_id: number): Promise<Memos[] | null> {
    return new Memos().listByTarget(target_id);
  }

  static _listByValidator(validator_id: number): Promise<Memos[] | null> {
    return new Memos().listByValidator(validator_id);
  }

  static _findPendingValidation(): Promise<Memos[] | null> {
    return new Memos().findAllPendingValidation();
  }

  static _findAutoGenerated(): Promise<Memos[] | null> {
    return new Memos().findAllAutoGenerated();
  }

  static _findByType(
    memo_type: MemoType,
    conditions: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    return new Memos().listByType(memo_type, conditions);
  }

  static _findByStatus(
    memo_status: MemoStatus,
    conditions: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    return new Memos().listByStatus(memo_status, conditions);
  }

  static _findBySession(affected_session: number): Promise<Memos[] | null> {
    return new Memos().listBySession(affected_session);
  }

  static _findByEntryId(entry_id: number): Promise<Memos[] | null> {
    return new Memos().listByEntryId(entry_id);
  }

  static _findPreventiveMemos(start_date: Date, end_date: Date): Promise<Memos[] | null> {
    return new Memos().listPreventiveMemos(start_date, end_date);
  }

  static _findCorrectiveMemos(start_date: Date, end_date: Date): Promise<Memos[] | null> {
    return new Memos().listCorrectiveMemos(start_date, end_date);
  }

  static _findByDateRange(
    start_date: Date,
    end_date: Date,
    filters: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    return new Memos().listByDateRange(start_date, end_date, filters);
  }

  static _findUrgentMemos(): Promise<Memos[] | null> {
    return new Memos().listUrgentMemos();
  }

  static async exportable(
    conditions: Record<string, any> = {},
    paginationOptions: { offset?: number; limit?: number } = {},
    view?: any,
  ): Promise<{
    revision: string;
    pagination: { offset?: number; limit?: number; count?: number };
    items: any[];
  }> {
    let items: any[] = [];
    const memos = await this._list(conditions, paginationOptions);
    if (memos) {
      items = await Promise.all(memos.map(async (memo) => await memo.toJSON(view)));
    }
    return {
      revision: await TenantRevision.getRevision(tableName.MEMOS),
      pagination: {
        offset: paginationOptions.offset || 0,
        limit: paginationOptions.limit || items.length,
        count: items.length,
      },
      items,
    };
  }

  static async getMemosStatistics(filters: Record<string, any> = {}): Promise<any> {
    return new Memos().getStatistics(filters);
  }

  static async autoEscalatePendingMemos(hours_threshold: number = 24): Promise<number> {
    const model = new Memos();
    const memosToEscalate = await model.listAllMemosForEscalation(hours_threshold);

    let escalatedCount = 0;
    for (const memoData of memosToEscalate) {
      const memo = new Memos().hydrate(memoData);

      // TODO: Récupérer N+1 hiérarchique du validator actuel
      // Pour l'instant, placeholder logic
      // const success = await model.escalateMemo(
      const success = await model.escalateOverdueMemos(
        memo.getId()!,
        memo.getValidatorUser()!,
        // 'timeout_24h',
      );
      if (success) {
        escalatedCount++;
      }
    }

    return escalatedCount;
  }

  static async detectUserSuspiciousPatterns(user_id: number, days: number = 30): Promise<any> {
    return new Memos().analyzeSuspiciousPatterns(user_id, days);
  }

  // === GETTERS FLUENT ===

  getId(): number | undefined {
    return this.id;
  }

  getGuid(): string | undefined {
    return this.guid;
  }

  getAuthorUser(): number | undefined {
    return this.author_user;
  }

  async getAuthorObj(): Promise<User | null> {
    if (!this.author_user) return null;
    if (!this.authorObj) {
      this.authorObj = (await User._load(this.author_user)) || undefined;
    }
    return this.authorObj || null;
  }

  getTargetUser(): number | undefined {
    return this.target_user;
  }

  async getTargetObj(): Promise<User | null> {
    if (!this.target_user) return null;
    if (!this.targetObj) {
      this.targetObj = (await User._load(this.target_user)) || undefined;
    }
    return this.targetObj || null;
  }

  getValidatorUser(): number | undefined {
    return this.validator_user;
  }

  async getValidatorObj(): Promise<User | null> {
    if (!this.validator_user) return null;
    if (!this.validatorObj) {
      this.validatorObj = (await User._load(this.validator_user)) || undefined;
    }
    return this.validatorObj || null;
  }

  getMemoType(): MemoType | undefined {
    return this.memo_type;
  }

  getMemoStatus(): MemoStatus | undefined {
    return this.memo_status;
  }

  getTitle(): string | undefined {
    return this.title;
  }

  getDescription(): string | undefined {
    return this.description;
  }

  getResponseUser(): string | undefined {
    return this.response_user;
  }

  getDetails(): string | undefined {
    return this.details;
  }

  getIncidentDatetime(): Date | undefined {
    return this.incident_datetime;
  }

  getAffectedSession(): number | undefined {
    return this.affected_session;
  }

  async getSessionObj(): Promise<WorkSessions | null> {
    if (!this.affected_session) return null;
    if (!this.sessionObj) {
      this.sessionObj = (await WorkSessions._load(this.affected_session)) || undefined;
    }
    return this.sessionObj || null;
  }

  getAffectedEntriesIds(): number[] | undefined {
    return this.affected_entries;
  }

  async getAffectedEntries(): Promise<TimeEntries[] | null> {
    if (!this.affected_entries || this.affected_entries.length === 0) return null;

    const entries: TimeEntries[] = [];
    for (const entryId of this.affected_entries) {
      const entry = await TimeEntries._load(entryId);
      if (entry) {
        entries.push(entry);
      }
    }

    return entries.length > 0 ? entries : null;
  }

  getAttachments(): Attachment[] | undefined {
    return this.attachments;
  }

  getValidatorComments(): string | undefined {
    return this.validator_comments;
  }

  getProcessedAt(): Date | undefined {
    return this.processed_at;
  }

  getRespondedAt(): Date | undefined {
    return this.processed_at;
  }

  isAutoGenerated(): boolean {
    return this.auto_generated || false;
  }

  // getAutoReason(): string | undefined {
  //   return this.auto_reason;
  // }

  getCreatedAt(): Date | undefined {
    return this.created_at;
  }

  getUpdatedAt(): Date | undefined {
    return this.updated_at;
  }

  // === SETTERS FLUENT ===

  setAuthorUser(author_user: number): Memos {
    this.author_user = author_user;
    return this;
  }

  setTargetUser(target_user: number): Memos {
    this.target_user = target_user;
    return this;
  }

  setValidatorUser(validator_user: number): Memos {
    this.validator_user = validator_user;
    return this;
  }

  setMemoType(type: MemoType): Memos {
    this.memo_type = type;
    return this;
  }

  setMemoStatus(status: MemoStatus): Memos {
    this.memo_status = status;
    return this;
  }

  setTitle(title: string): Memos {
    this.title = title;
    return this;
  }

  setDescription(description: string): Memos {
    this.description = description;
    return this;
  }

  setResponseUser(response: string): Memos {
    this.response_user = response;
    return this;
  }

  setRespondedAt(datetime: Date): Memos {
    this.responded_at = datetime;
    return this;
  }

  setDetails(values: string): Memos {
    this.details = values;
    return this;
  }

  setIncidentDatetime(datetime: Date): Memos {
    this.incident_datetime = datetime;
    return this;
  }

  setAffectedSession(session: number): Memos {
    this.affected_session = session;
    return this;
  }

  setAffectedEntriesIds(entries: number[]): Memos {
    this.affected_entries = entries;
    return this;
  }

  setAttachments(attachments: Array<string | Attachment>): Memos {
    this.attachments = MemosValidationUtils.normalizeAttachments(attachments);
    return this;
  }

  setValidatorComments(comments: string): Memos {
    this.validator_comments = comments;
    return this;
  }

  setAutoGenerated(auto: boolean, description?: string | null): Memos {
    this.auto_generated = auto;
    if (description) this.description = description;
    return this;
  }

  // === VALIDATION MÉTIER ===

  isPreventive(): boolean {
    if (!this.incident_datetime || !this.created_at) return false;
    return this.created_at < this.incident_datetime;
  }

  isCorrective(): boolean {
    if (!this.incident_datetime || !this.created_at) return false;
    return this.created_at >= this.incident_datetime;
  }

  isUrgent(): boolean {
    if (!this.incident_datetime) return false;

    const now = new Date();
    const twoDaysFromNow = new Date(now);
    twoDaysFromNow.setDate(twoDaysFromNow.getDate() + 2);

    return this.incident_datetime <= twoDaysFromNow && this.isPending();
  }

  isPending(): boolean {
    return this.memo_status === MemoStatus.SUBMITTED || this.memo_status === MemoStatus.PENDING;
  }

  isApproved(): boolean {
    return this.memo_status === MemoStatus.APPROVED;
  }

  isRejected(): boolean {
    return this.memo_status === MemoStatus.REJECTED;
  }

  isDraft(): boolean {
    return this.memo_status === MemoStatus.DRAFT;
  }

  // === GESTION DU CYCLE DE VIE ===
  async submitMemosForValidation(
    response_user: string,
    attachments?: Array<string | Attachment>,
  ): Promise<void> {
    if (!this.id) throw new Error('Cannot submit memo without ID');

    const success = await this.submitResponse(this.id, response_user, attachments);
    if (success) {
      this.memo_status = MemoStatus.SUBMITTED;
      this.response_user = response_user;
      this.attachments = MemosValidationUtils.normalizeAttachments(attachments);
    } else {
      throw new Error('Failed to submit memo for validation');
    }
  }

  async submitMemosForResponse(): Promise<void> {
    if (!this.id) {
      throw new Error('Cannot submit memo without ID');
    }
    const success = await this.submitForResponse(this.id);
    if (success) {
      this.memo_status = MemoStatus.PENDING;
    } else {
      throw new Error('Failed to submit memo for validation');
    }
  }

  async approve(validator: number, comments?: string): Promise<void> {
    if (!this.id) {
      throw new Error('Cannot approve memo without ID');
    }
    const success = await this.processValidation(this.id, validator, MemoStatus.APPROVED, comments);
    // const success = await this.validateMemo(this.id, validator, 'approved', comments);
    if (success) {
      this.memo_status = MemoStatus.APPROVED;
      this.validator_user = validator;
      this.validator_comments = comments;
      this.processed_at = new Date();
    } else {
      throw new Error('Failed to approve memo');
    }
  }

  async reject(validator: number, comments?: string): Promise<void> {
    if (!this.id) {
      throw new Error('Cannot reject memo without ID');
    }
    const success = await this.processValidation(this.id, validator, MemoStatus.REJECTED, comments);
    if (success) {
      this.memo_status = MemoStatus.REJECTED;
      this.validator_user = validator;
      this.validator_comments = comments;
      this.processed_at = new Date();
    } else {
      throw new Error('Failed to reject memo');
    }
  }

  async escalate(new_validator: number, reason: string): Promise<void> {
    if (!this.id) {
      throw new Error('Cannot escalate memo without ID');
    }
    const success = await this.escalateMemo(this.id, new_validator, reason);
    if (success) {
      this.validator_user = new_validator;
      this.memo_status = MemoStatus.PENDING;
    } else {
      throw new Error('Failed to escalate memo');
    }
  }

  // === GESTION DES PIÈCES JOINTES ===

  async addFileAttachment(attachment: Array<string | Attachment>): Promise<void> {
    if (!this.id) throw new Error('Cannot add attachment to memo without ID');

    const success = await this.addAttachment(this.id, attachment);
    if (success) {
      if (!this.attachments) this.attachments = [];
      const newAttachment = MemosValidationUtils.normalizeAttachments(attachment);
      this.attachments.push(...newAttachment);
    } else {
      throw new Error('Failed to add attachment');
    }
  }

  async removeFileAttachment(index: number): Promise<void> {
    if (!this.id) {
      throw new Error('Cannot remove attachment from memo without ID');
    }
    const success = await this.removeAttachment(this.id, index);
    if (success && this.attachments && Array.isArray(this.attachments)) {
      this.attachments.splice(index, 1);
    } else {
      throw new Error('Failed to remove attachment');
    }
  }

  // === MÉTHODES DE CHARGEMENT ===

  async load(identifier: any, byGuid: boolean = false): Promise<Memos | null> {
    let data = null;

    if (byGuid) {
      data = await this.findByGuid(identifier);
    } else {
      data = await this.find(Number(identifier));
    }

    if (!data) return null;
    return this.hydrate(data);
  }

  async list(
    conditions: Record<string, any> = {},
    paginationOptions: { offset?: number; limit?: number } = {},
  ): Promise<Memos[] | null> {
    const dataset = await this.listAll(conditions, paginationOptions);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByAuthor(author_id: number): Promise<Memos[] | null> {
    const dataset = await this.listAllByAuthor(author_id);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByTarget(target_id: number): Promise<Memos[] | null> {
    const dataset = await this.listAllByTarget(target_id);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByValidator(validator_id: number): Promise<Memos[] | null> {
    const dataset = await this.listAllByValidator(validator_id);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async findAllPendingValidation(): Promise<Memos[] | null> {
    const dataset = await this.findPendingValidation();
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async findAllAutoGenerated(): Promise<Memos[] | null> {
    const dataset = await this.findAutoGenerated();
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByType(
    memo_type: MemoType,
    conditions: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    const dataset = await this.findByType(memo_type, conditions);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByStatus(
    memo_status: MemoStatus,
    conditions: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    const dataset = await this.findByStatus(memo_status, conditions);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listBySession(affected_session: number): Promise<Memos[] | null> {
    const dataset = await this.findBySession(affected_session);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByEntryId(entry_id: number): Promise<Memos[] | null> {
    const dataset = await this.findByEntryId(entry_id);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listPreventiveMemos(start_date: Date, end_date: Date): Promise<Memos[] | null> {
    const dataset = await this.findPreventiveMemos(start_date, end_date);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listCorrectiveMemos(start_date: Date, end_date: Date): Promise<Memos[] | null> {
    const dataset = await this.findCorrectiveMemos(start_date, end_date);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listByDateRange(
    start_date: Date,
    end_date: Date,
    filters: Record<string, any> = {},
  ): Promise<Memos[] | null> {
    const dataset = await this.findByDateRange(start_date, end_date, filters);
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listUrgentMemos(): Promise<Memos[] | null> {
    const dataset = await this.findUrgentMemos();
    if (!dataset || dataset.length === 0) return null;
    return dataset.map((data) => new Memos().hydrate(data));
  }

  async listAllMemosForEscalation(hours_threshold: number = 24): Promise<any[]> {
    return await this.findMemosForEscalation(hours_threshold);
  }

  async analyzeSuspiciousPatterns(user: number, days: number = 30): Promise<any> {
    return await this.findSuspiciousPatterns(user, days);
  }

  async getStatistics(filters: Record<string, any> = {}): Promise<any> {
    return await this.getMemosStatistics(filters);
  }

  // === MÉTHODES DE BASE ===

  isNew(): boolean {
    return this.id === undefined;
  }

  async save(): Promise<void> {
    try {
      if (this.isNew()) {
        await this.create();
      } else {
        await this.update();
      }
    } catch (error: any) {
      throw new Error(error.message || error);
    }
  }

  async delete(): Promise<boolean> {
    if (this.id !== undefined) {
      await W.isOccur(!this.id, `${G.identifierMissing.code}: Memos Delete`);
      return await this.trash(this.id);
    }
    return false;
  }

  async toJSON(view: ViewMode = responseValue.FULL): Promise<object> {
    const author = await this.getAuthorObj();
    const target = await this.getTargetObj();
    const validator = await this.getValidatorObj();
    const session = await this.getSessionObj();
    const entries = await this.getAffectedEntries();

    const baseData = {
      [RS.GUID]: this.guid,
      [RS.MEMO_TYPE]: this.memo_type,
      [RS.MEMO_STATUS]: this.memo_status,
      [RS.TITLE]: this.title,
      [RS.DESCRIPTION]: this.description,
      [RS.RESPONSE_USER]: this.response_user,
      [RS.RESPONDED_AT]: this.responded_at,
      [RS.INCIDENT_DATE_TIME]: this.incident_datetime,
      [RS.AUTO_GENERATED]: this.auto_generated,
      // [RS.AUTO_REASON]: this.auto_reason,
      [RS.ATTACHMENTS]: this.attachments,
      [RS.VALIDATOR_COMMENTS]: this.validator_comments,
      [RS.PROCESSED_AT]: this.processed_at,
      [RS.CREATED_AT]: this.created_at,
      [RS.UPDATED_AT]: this.updated_at,
      [RS.AFFECTED_ENTRIES]: entries
        ? await Promise.all(entries.map(async (entry) => entry.getGuid()))
        : null,
    };

    if (view === responseValue.MINIMAL) {
      return {
        ...baseData,
        [RS.AUTHOR_USER]: author?.getGuid(),
        [RS.TARGET_USER]: target?.getGuid(),
        [RS.VALIDATOR_USER]: validator?.getGuid(),
        [RS.AFFECTED_SESSION]: session?.getGuid(),
      };
    }
    return {
      ...baseData,
      [RS.AUTHOR_USER]: author ? author.toJSON() : null,
      [RS.TARGET_USER]: target ? target.toJSON() : null,
      [RS.VALIDATOR_USER]: validator ? validator.toJSON() : null,
      [RS.AFFECTED_SESSION]: session ? await session.toJSON(responseValue.MINIMAL) : null,
      // [RS.PROCESSED_AT]: this.processed_at,
      // Informations calculées
      // [RS.IS_PREVENTIVE]: this.isPreventive(),
      // [RS.IS_CORRECTIVE]: this.isCorrective(),
      // [RS.IS_URGENT]: this.isUrgent(),
      // [RS.IS_PENDING]: this.isPending(),
      // [RS.IS_APPROVED]: this.isApproved(),
      // [RS.IS_REJECTED]: this.isRejected(),
      // [RS.IS_DRAFT]: this.isDraft(),
      [RS.DETAILS]: this.details,
    };
  }

  // === MÉTHODES PRIVÉES ===

  private hydrate(data: any): Memos {
    this.id = data.id;
    this.guid = data.guid;
    this.author_user = data.author_user;
    this.target_user = data.target_user;
    this.validator_user = data.validator_user;
    this.memo_type = data.memo_type;
    this.memo_status = data.memo_status;
    this.title = data.title;
    this.description = data.description;
    this.response_user = data.response_user;
    this.responded_at = data.responded_at;
    this.incident_datetime = data.incident_datetime;
    this.affected_session = data.affected_session;
    this.affected_entries = data.affected_entries;
    this.attachments = data.attachments;
    this.validator_comments = data.validator_comments;
    this.processed_at = data.processed_at;
    this.auto_generated = data.auto_generated;
    this.details = data.details;
    // this.auto_reason = data.auto_reason;
    this.created_at = data.created_at;
    this.updated_at = data.updated_at;
    return this;
  }
}
