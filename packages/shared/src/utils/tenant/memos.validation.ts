// utils/memos.validation.ts
import {
  MEMOS_DEFAULTS,
  MEMOS_VALIDATION,
  MemoStatus,
  MemoType,
} from '../../constants/tenant/memos.js';
import { MemoContent, Message } from '../../types/tenant/memos.js';

export class MemosValidationUtils {
  /**
   * Validates GUID
   */
  static validateGuid(guid: string): boolean {
    if (!guid || typeof guid !== 'string') return false;
    const trimmed = guid.trim();

    // Check length
    if (
      trimmed.length < MEMOS_VALIDATION.GUID.MIN_LENGTH ||
      trimmed.length > MEMOS_VALIDATION.GUID.MAX_LENGTH
    ) {
      return false;
    }

    const uuidRegex = /^[0-9]+$/;
    // UUID v4 regex
    // const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(trimmed);
  }

  /**
   * Validates author user
   */
  static validateAuthorUserId(authorUserId: string): boolean {
    if (!authorUserId || typeof authorUserId !== 'string') return false;

    const trimmed = authorUserId.trim();
    if (
      trimmed.length >= MEMOS_VALIDATION.AUTHOR_USER.MIN_LENGTH ||
      trimmed.length <= MEMOS_VALIDATION.AUTHOR_USER.MAX_LENGTH
    ) {
      return false;
    }

    const uuidRegex = /^[0-9]+$/;
    return uuidRegex.test(trimmed);
  }

  /**
   * Validates target user
   */
  static validateTargetUserId(targetUserId: string | null): boolean {
    if (targetUserId === null || targetUserId === undefined) return true;
    if (typeof targetUserId !== 'string') return false;

    const trimmed = targetUserId.trim();
    if (
      trimmed.length >= MEMOS_VALIDATION.TARGET_USER.MIN_LENGTH ||
      trimmed.length <= MEMOS_VALIDATION.TARGET_USER.MAX_LENGTH
    ) {
      return false;
    }
    const uuidRegex = /^[0-9]+$/;
    return uuidRegex.test(trimmed);
  }

  /**
   * Validates validator user
   */
  static validateValidatorUserId(validatorUserId: string | null): boolean {
    if (validatorUserId === null || validatorUserId === undefined) return true;
    if (typeof validatorUserId !== 'string') return false;
    const trimmed = validatorUserId.trim();
    if (
      trimmed.length >= MEMOS_VALIDATION.VALIDATOR_USER.MIN_LENGTH ||
      trimmed.length <= MEMOS_VALIDATION.VALIDATOR_USER.MAX_LENGTH
    ) {
      return false;
    }
    const uuidRegex = /^[0-9]+$/;
    return uuidRegex.test(trimmed);
  }

  /**
   * Validates memo type
   */
  static validateMemoType(memoType: string): boolean {
    if (!memoType || typeof memoType !== 'string') return false;
    return Object.values(MemoType).includes(memoType as MemoType);
  }

  /**
   * Validates memo status
   */
  static validateMemoStatus(status: string): boolean {
    if (!status || typeof status !== 'string') return false;
    return Object.values(MemoStatus).includes(status as MemoStatus);
  }

  /**
   * Validates memo title
   */
  static validateTitle(title: string): boolean {
    if (!title || typeof title !== 'string') return false;
    const trimmed = title.trim();
    return (
      trimmed.length >= MEMOS_VALIDATION.TITLE.MIN_LENGTH &&
      trimmed.length <= MEMOS_VALIDATION.TITLE.MAX_LENGTH
    );
  }

  /**
   * Validates incident datetime
   */
  static validateIncidentDatetime(incidentDatetime: Date | string | null): boolean {
    if (incidentDatetime === null || incidentDatetime === undefined) return true;
    const date = new Date(incidentDatetime);
    if (isNaN(date.getTime())) return false;

    // Incident cannot be in the future (allowing current time with 1 minute tolerance)
    const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'Africa/Douala' }));
    // const now = new Date();
    now.setMinutes(now.getMinutes() + 1);
    return date <= now;
  }

  /**
   * Validates affected session ID
   */
  static validateAffectedSessionId(sessionId: string | null): boolean {
    if (sessionId === null || sessionId === undefined) return true;
    if (typeof sessionId !== 'string') return false;
    const trimmed = sessionId.trim();
    if (
      trimmed.length >= MEMOS_VALIDATION.AFFECTED_SESSION.MIN_LENGTH ||
      trimmed.length <= MEMOS_VALIDATION.AFFECTED_SESSION.MAX_LENGTH
    ) {
      return false;
    }

    const uuidRegex = /^[0-9]+$/;
    return uuidRegex.test(trimmed);
  }

  /**
   * Validates affected entries array
   */
  static validateAffectedEntries(entries: any): boolean {
    if (entries === null || entries === undefined) return true;
    if (!Array.isArray(entries)) return false;

    return entries.every((entryId) => {
      if (typeof entryId !== 'string') return false;

      const trimmed = entryId.trim();
      if (
        trimmed.length >= MEMOS_VALIDATION.AFFECTED_ENTRIES.MIN_LENGTH &&
        trimmed.length <= MEMOS_VALIDATION.AFFECTED_ENTRIES.MAX_LENGTH
      ) {
        return false;
      }

      const uuidRegex = /^[0-9]+$/;
      return uuidRegex.test(trimmed);
    });
  }

  /**
   * Validates auto generated flag
   */
  static validateAutoGenerated(autoGenerated: boolean): boolean {
    return typeof autoGenerated === 'boolean';
  }

  /**
   * Validates pagination parameters
   */
  static validatePaginationParams(offset: number, limit: number): boolean {
    return (
      Number.isInteger(offset) &&
      Number.isInteger(limit) &&
      offset >= 0 &&
      limit > 0 &&
      limit <= MEMOS_DEFAULTS.PAGINATION?.MAX_LIMIT
    );
  }

  /**
   * Validates that self-validation is not allowed
   */
  static validateNotSelfValidation(authorUserId: number, validatorUserId: number): boolean {
    return authorUserId !== validatorUserId;
  }

  /**
   * Checks if memo can be modified
   */
  static canModifyMemo(status: string): boolean {
    // Cannot modify processed (approved/rejected) memos
    return status !== MemoStatus.APPROVED && status !== MemoStatus.REJECTED;
  }

  /**
   * Validates that validator is required for approval/rejection
   */
  static isValidatorRequired(status: string): boolean {
    return status === MemoStatus.APPROVED || status === MemoStatus.REJECTED;
  }

  /**
   * Validates filter data for searches
   */
  static validateFilterData(data: any): boolean {
    return (
      (data.author_user && this.validateAuthorUserId(data.author_user)) ||
      (data.target_user && this.validateTargetUserId(data.target_user)) ||
      (data.validator_user && this.validateValidatorUserId(data.validator_user)) ||
      (data.memo_type && this.validateMemoType(data.memo_type)) ||
      (data.memo_status && this.validateMemoStatus(data.memo_status)) ||
      (data.auto_generated !== undefined && this.validateAutoGenerated(data.auto_generated)) ||
      (data.affected_session && this.validateAffectedSessionId(data.affected_session)) ||
      (data.incident_datetime_from && !isNaN(new Date(data.incident_datetime_from).getTime())) ||
      (data.incident_datetime_to && !isNaN(new Date(data.incident_datetime_to).getTime())) ||
      (data.processed_at_from && !isNaN(new Date(data.processed_at_from).getTime())) ||
      (data.processed_at_to && !isNaN(new Date(data.processed_at_to).getTime())) ||
      (data.guid && this.validateGuid(data.guid))
    );
  }

  /**
   * Gets memo summary statistics
   */
  static getMemoSummary(
    memos: any[],
    userId?: number,
  ): {
    totalMemos: number;
    authoredMemos: number;
    targetedMemos: number;
    validatedMemos: number;
    statusCounts: Record<string, number>;
    typeCounts: Record<string, number>;
    autoGeneratedCount: number;
    avgProcessingTimeHours: number;
  } {
    const filteredMemos = userId
      ? memos.filter(
          (memo) =>
            memo.author_user === userId ||
            memo.target_user === userId ||
            memo.validator_user === userId,
        )
      : memos;

    const summary = {
      totalMemos: filteredMemos.length,
      authoredMemos: 0,
      targetedMemos: 0,
      validatedMemos: 0,
      statusCounts: {} as Record<string, number>,
      typeCounts: {} as Record<string, number>,
      autoGeneratedCount: 0,
      avgProcessingTimeHours: 0,
    };

    let totalProcessingTime = 0;
    let processedCount = 0;

    filteredMemos.forEach((memo) => {
      if (userId) {
        if (memo.author_user === userId) summary.authoredMemos++;
        if (memo.target_user === userId) summary.targetedMemos++;
        if (memo.validator_user === userId) summary.validatedMemos++;
      }

      const status = memo.memo_status;
      summary.statusCounts[status] = (summary.statusCounts[status] || 0) + 1;

      const type = memo.memo_type;
      summary.typeCounts[type] = (summary.typeCounts[type] || 0) + 1;

      if (memo.auto_generated) {
        summary.autoGeneratedCount++;
      }

      // Calculate processing time for processed memos
      if (memo.processed_at && memo.created_at) {
        const processingTime =
          new Date(memo.processed_at).getTime() - new Date(memo.created_at).getTime();
        totalProcessingTime += processingTime;
        processedCount++;
      }
    });

    summary.avgProcessingTimeHours =
      processedCount > 0 ? totalProcessingTime / processedCount / (1000 * 60 * 60) : 0;

    return summary;
  }

  /**
   * Generates memo workflow report
   */
  static generateMemoWorkflowReport(memos: any[], period: { start: Date; end: Date }) {
    const periodMemos = memos.filter((memo) => {
      const createdAt = new Date(memo.created_at);
      return createdAt >= period.start && createdAt <= period.end;
    });

    const summary = this.getMemoSummary(periodMemos);

    // Calculate metrics
    const approvalRate =
      (summary.statusCounts[MemoStatus.APPROVED]! /
        (summary.statusCounts[MemoStatus.APPROVED]! + summary.statusCounts[MemoStatus.REJECTED]! ||
          1)) *
      100;

    const pendingRate = (summary.statusCounts[MemoStatus.PENDING]! / summary.totalMemos) * 100;

    // Identify bottlenecks
    const bottlenecks: string[] = [];
    if (pendingRate > 30) {
      bottlenecks.push('High percentage of pending memos');
    }
    if (summary.avgProcessingTimeHours > 72) {
      bottlenecks.push('Long average processing time');
    }
    if (summary.autoGeneratedCount / summary.totalMemos > 0.5) {
      bottlenecks.push('High volume of auto-generated memos');
    }

    return {
      period: {
        start: period.start.toISOString(),
        end: period.end.toISOString(),
      },
      summary,
      metrics: {
        approvalRate: Number(approvalRate.toFixed(2)),
        pendingRate: Number(pendingRate.toFixed(2)),
        avgProcessingHours: Number(summary.avgProcessingTimeHours.toFixed(2)),
      },
      bottlenecks,
      recommendations: this.generateRecommendations(summary, bottlenecks),
    };
  }

  static normalizeMessages(content: MemoContent[]): Message[] {
    return content.flatMap((entry) =>
      Array.isArray(entry.message) ? entry.message : [entry.message],
    );
  }

  /**
   * Generates recommendations based on memo analysis
   */
  private static generateRecommendations(summary: any, bottlenecks: string[]): string[] {
    const recommendations: string[] = [];

    if (bottlenecks.includes('High percentage of pending memos')) {
      recommendations.push('Consider assigning more validators or streamlining approval process');
    }

    if (bottlenecks.includes('Long average processing time')) {
      recommendations.push('Review validation workflow and set processing time targets');
    }

    if (bottlenecks.includes('High volume of auto-generated memos')) {
      recommendations.push('Investigate underlying issues causing automatic memo generation');
    }

    if (summary.statusCounts[MemoStatus.REJECTED] > summary.statusCounts[MemoStatus.APPROVED]) {
      recommendations.push('Review memo submission guidelines and provide better training');
    }

    return recommendations;
  }
}
